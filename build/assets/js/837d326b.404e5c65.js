"use strict";(self.webpackChunkredback_documentation=self.webpackChunkredback_documentation||[]).push([[4174],{53949:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>p,frontMatter:()=>s,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"project-4/iot/Data_parsing_guide_accelerometer","title":"Data Parsing Implementation in Node.js for Arduino Sensor Data","description":"Overview","source":"@site/docs/project-4/iot/Data_parsing_guide_accelerometer.mdx","sourceDirName":"project-4/iot","slug":"/project-4/iot/Data_parsing_guide_accelerometer","permalink":"/redback-documentation/docs/project-4/iot/Data_parsing_guide_accelerometer","draft":false,"unlisted":false,"editUrl":"https://github.com/Redback-Operations/redback-documentation/blob/main/docs/project-4/iot/Data_parsing_guide_accelerometer.mdx","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"final-code-documentation-and-tips-for-futur","permalink":"/redback-documentation/docs/project-4/iot/final-code-documentation-and-tips-for-futur"},"next":{"title":"Report on Implementing filterpy for Enhanced Kalman Filtering in Data Analysis","permalink":"/redback-documentation/docs/project-4/iot/Filterpy_library_for data_analysis"}}');var i=a(74848),r=a(28453);const s={sidebar_position:3},o="Data Parsing Implementation in Node.js for Arduino Sensor Data",d={},c=[{value:"Overview",id:"overview",level:2},{value:"Rationale",id:"rationale",level:2},{value:"Data Parsing Process",id:"data-parsing-process",level:2},{value:"Step 1: Data Reception",id:"step-1-data-reception",level:3},{value:"Step 2: Parsing Logic",id:"step-2-parsing-logic",level:3},{value:"Benefits",id:"benefits",level:2},{value:"Conclusion",id:"conclusion",level:2}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"data-parsing-implementation-in-nodejs-for-arduino-sensor-data",children:"Data Parsing Implementation in Node.js for Arduino Sensor Data"})}),"\n",(0,i.jsx)(t.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(t.p,{children:"For this project, the goal was to capture sensor data from an Arduino device, transmit it via a serial connection, and store it in a MongoDB database using a Node.js application. To enhance the utility and accessibility of the stored data for future querying and analysis, it was essential to implement data parsing before data storage."}),"\n",(0,i.jsx)(t.h2,{id:"rationale",children:"Rationale"}),"\n",(0,i.jsx)(t.p,{children:"Raw data transmitted from Arduino typically includes various sensor readings in a non-structured format, which might be interspersed with metadata or other information. Storing such data directly into a database can lead to issues with data retrieval, increase the complexity of query operations, and potentially affect performance due to the unstructured nature of the data. By parsing the data before storage:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Structure is imposed, making the database schema more consistent and predictable."}),"\n",(0,i.jsx)(t.li,{children:"Data integrity is enhanced as only valid and correctly formatted data is stored."}),"\n",(0,i.jsx)(t.li,{children:"Query performance is improved, allowing for more efficient data analysis and retrieval operations."}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"data-parsing-process",children:"Data Parsing Process"}),"\n",(0,i.jsx)(t.h3,{id:"step-1-data-reception",children:"Step 1: Data Reception"}),"\n",(0,i.jsx)(t.p,{children:"The Node.js application listens to the serial port for data transmitted by the Arduino. Each piece of data received is a string that potentially contains multiple sensor readings formatted in a predefined pattern.\r\nExample of raw data received:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-text",children:"18:45:19.234 -> Speed: 1.01 Direction: Down\n"})}),"\n",(0,i.jsx)(t.h3,{id:"step-2-parsing-logic",children:"Step 2: Parsing Logic"}),"\n",(0,i.jsx)(t.p,{children:"The data parsing function extracts relevant pieces of information from the raw data strings using regular expressions. This method ensures that only the necessary data (e.g., speed and direction) is extracted, ignoring any irrelevant metadata or formatting characters.\r\nParsing Function Example:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"javascript\r\nfunction parseData(data) {\r\n    const speedMatch = data.match(/Speed: ([\\d.]+)/);\r\n    const directionMatch = data.match(/Direction: (\\w+)/);\r\n    if (speedMatch && directionMatch) {\r\n        return {\r\n            speed: parseFloat(speedMatch[1]),\r\n            direction: directionMatch[1],\r\n            timestamp: new Date() // Adding a timestamp for each data entry\r\n        };\r\n    }\r\n    return null; // Return null if data does not match expected pattern\r\n}\r\n\n"})}),"\n",(0,i.jsx)(t.h2,{id:"benefits",children:"Benefits"}),"\n",(0,i.jsx)(t.p,{children:"Implementing data parsing within this Node.js application provided several key benefits:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Improved Data Management"}),": Structured data storage makes it easier to manage, update, and delete data entries."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Enhanced Analytical Capabilities"}),": Well-structured data supports more complex queries and analytical operations such as aggregations and statistical analysis."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Scalability"}),": As the system scales and handles more data sources or varied data formats, maintaining structured data input becomes crucial for system performance and reliability."]}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(t.p,{children:"Data parsing plays a critical role in the efficient and effective storage and management of sensor data in IoT applications. By structuring data before it enters the database, the system ensures that the data is ready for immediate use in applications and analyses, thus enhancing the overall utility of the data collection system."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://github.com/Bhumika-Chauhan09/redback-orion/blob/main/csv.js",children:"GitHub Project Link"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.a,{href:"https://drive.google.com/file/d/1Oz2dcAg6w2c4dPY5FORJOHEOjJ0Ecvb1/view?usp=drive_link",children:"Mongo prior steps Link"})})]})}function p(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},28453:(e,t,a)=>{a.d(t,{R:()=>s,x:()=>o});var n=a(96540);const i={},r=n.createContext(i);function s(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);